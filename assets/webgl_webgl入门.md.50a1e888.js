import{_ as e,c as r,o as t,a as l}from"./app.b8d11a0b.js";const L=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"关于 Three js","slug":"关于-three-js","link":"#关于-three-js","children":[{"level":3,"title":"Threejs 的作用","slug":"threejs-的作用","link":"#threejs-的作用","children":[]}]}],"relativePath":"webgl/webgl入门.md"}'),p={name:"webgl/webgl入门.md"},o=l('<h2 id="关于-three-js" tabindex="-1">关于 Three js <a class="header-anchor" href="#关于-three-js" aria-hidden="true">#</a></h2><ol><li><p>为什么学习 Three js? 首先我们需要弄明白 Threejs 是什么？学他做甚？ 学习 Three js，其实我们是在学习怎么去做 Web 3D 展示；</p><p>所以我们来看下 Threejs 是什么： 简单来说它是一个 javascript 3d 库；</p><blockquote><p>一个易于使用、轻量级、跨浏览器的通用 3D 库。当前构建仅包含 WebGL 渲染器，但 WebGPU（实验性）、SVG 和 CSS3D 渲染器也可作为插件使用；</p></blockquote><p>那引出一个问题：WebGL 渲染器是什么？</p></li><li><p><strong>WebGL 渲染器是什么？</strong></p><blockquote><p>WebGL 是一套用于渲染 2D 和 3D 图形的标准图形库；WebGL 提供了底层的渲染 API，对于传统 Web 开发者来说，使用 WebGL API 是比较复杂的，需要补充大量的 OpenGL ES 相关知识。</p></blockquote><p>来继续说一下 OpenGL 和 OpenGl ES?</p><ul><li><p>OpenGL(Open Graphics Library)是一套规范，硬件厂商基于自家 GPU 硬件指令等来实现这个规范；开发者编写依据 OpenGL 规范，就可以在机器上看到对应的绘制结果；</p></li><li><p><a href="https://zh.wikipedia.org/wiki/OpenGL_ES" target="_blank" rel="noreferrer">OpenGl ES：</a> OpenGL ES 是 OpenGL 的子集，针对手机、PDA 和游戏主机等嵌入式设备而设计。 <strong>OpenGL ES 是从 OpenGL 裁剪定制而来的，去除了 glBegin/glEnd，四边形（GL_QUADS）、多边形（GL_POLYGONS）等复杂图元等许多非绝对必要的特性。</strong></p></li><li><p><a href="https://zh.wikipedia.org/wiki/WebGL" target="_blank" rel="noreferrer">WebGL</a></p><blockquote><p>WebGL 是一种 JavaScript API，用于在不使用插件的情况下在任何兼容的网页浏览器中呈现交互式 2D 和 3D 图形。WebGL 完全集成到浏览器的所有网页标准中，可将影像处理和效果的 GPU 加速使用方式当做网页 Canvas 的一部分。WebGL 元素可以加入其他 HTML 元素之中并与网页或网页背景的其他部分混合。WebGL 程序由 JavaScript 编写的句柄和 OpenGL Shading Language（GLSL）编写的着色器代码组成，该语言类似于 C 或 C++，并在电脑的图形处理器（GPU）上执行。WebGL 由非营利 Khronos Group 设计和维护。 WebGL 1.0 基于 OpenGL ES 2.0，并提供了 3D 图形的 API。它使用 HTML5 Canvas 并允许利用文档对象模型接口。WebGL 2.0 基于 OpenGL ES 3.0，确保了提供许多选择性的 WebGL 1.0 扩展，并引入新的 API。可利用部分 Javascript 实现自动存储器管理;</p></blockquote></li></ul><p>简单理解：WebGL 是一个遵循 OpenGL ES 规范，为网页浏览器能呈现交互式 2D 和 3D 图形的 JavaScript API；</p></li></ol><ul><li>Three.js 再次定义： <strong>它是一个基于 WebGL Api 封装的，用于在浏览器中绘制 3D 图形的 JS 库；</strong></li></ul><ol start="3"><li><p>涉及的一些图形基础的概念？</p><ul><li><p><a href="https://zh.wikipedia.org/zh/%E7%AC%9B%E5%8D%A1%E5%B0%94%E5%9D%90%E6%A0%87%E7%B3%BB" target="_blank" rel="noreferrer">笛卡尔坐标系</a></p></li><li><p>矩阵和矩阵变换： 矩阵用于坐标变换，比如移动，旋转，缩放...</p></li></ul></li></ol><p>为什么要知道这些呢？--图形的展示，变换，都是基于在某一个坐标体系下，做顶点的变换；</p><ol start="4"><li><strong>WebGL 的工作原理</strong><blockquote><p>主要参考：<a href="https://www.cnblogs.com/wanbo/p/6754066.html" target="_blank" rel="noreferrer">图解 WebGL&amp;Three.js 工作原理 </a></p></blockquote></li></ol><ul><li><p>4.1）<strong>WebGL 绘图 API</strong>： 首先，我们看下 WebGL 绘图 API 提供的所有的 API:</p><ul><li>画点：gl.POINTS</li><li>画线：gl.LINES</li><li>画三角形：gl.TRIANGLES</li></ul><p>看到这 3 个 API，我们发现除了基础的点和线，面的话只有三角形，也就是说再怎么复杂的模型，都是由三角形构成；</p></li><li><p>4.2）<strong>WebGL 绘制流程</strong> 简单说来，WebGL 绘制过程包括以下三步： 1、获取<strong>顶点坐标</strong> 2、<strong>图元</strong>装配（即画出一个个三角形） 3、光栅化（生成<strong>片元</strong>，即一个个像素点）</p></li></ul><p>顶点坐标---[装配]--&gt;图元（图形）---[栅格化]--&gt;片元---&gt;像素</p><blockquote><p>片元： 片元是在图元经过光栅化阶段后，被分割成一个个像素大小的基本单位。片元其实已经很接近像素了，但是它还不是像素。片元包含了比 RGBA 更多的信息，比如可能有深度值，法线，纹理坐标等等信息。片元需要在通过一些测试（如深度测试）后才会最终成为像素。可能会有多个片元竞争同一个像素，而这些测试会最终筛选出一个合适的片元，丢弃法线和纹理坐标等不需要的信息后，成为像素；</p></blockquote><p>接下来我们说下这个处理过程的一些细节；</p><ul><li><p>4.2.1 获取<strong>顶点坐标</strong> 顶点坐标一般都是来源于三维软件导出，或者是框架生成； 在获取到顶点坐标后，实现侧通常会将它存储在显存，即缓存区内，方便 GPU 更快读取。</p></li><li><p>4.2.2 <strong>图元装配</strong> 图元配置，简单来说就是连接顶点画线，从而生成三角形的面； 这个过程并不是完全自动的，开发者可以通过构建<strong>顶点着色器</strong>来控制图元的生成；</p><p>这里疑问为什么需要<strong>顶点着色器</strong>？它的作用或目的是什么？</p><blockquote><p>着色器(Shader)是运行在 GPU 上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p></blockquote><blockquote><p>顶点着色器（Vertex Shader）是你写进 GLSL 中的一个方法，<strong>每个顶点调用一次，在这个方法中做一些数学运算后设置了一个特殊的 gl_Position 变量， 这个变量就是该顶点转换到裁剪空间中的坐标值，GPU 接收该值并将其保存起来</strong>。</p></blockquote><p>所以简单来说顶点着色器的作用就是坐标计算；</p></li><li><p>4.2.3 <strong>光栅化</strong> 光栅化过程及是由片元着色器对‘模型’进行细分和上色的过程； 光栅化之后就形成了片元；（ps：什么是片元，上面有详细说明）</p><p>所以最后总结下 WebGL 的整个工作流程：</p><ul><li>数据模型--》生成顶点着色器--》转换到裁剪空间中的坐标值--》图片装配--》生成图元--》生成片元着色器--》光栅化--》片元---》像素、</li></ul><blockquote><p>个人简化理解：及从点的集合到面的切分，再到‘样式’，这是一个从模糊到清晰，也是一个从大体到局部细节的拆分和处理过程；</p></blockquote></li></ul><h3 id="threejs-的作用" tabindex="-1">Threejs 的作用 <a class="header-anchor" href="#threejs-的作用" aria-hidden="true">#</a></h3><p>下图来源<a href="https://www.cnblogs.com/wanbo/p/6754066.html" target="_blank" rel="noreferrer">图解 WebGL&amp;Three.js 工作原理</a><img src="https://raw.githubusercontent.com/huwuji/blog/master/FE_Tutorials/ThreeJs/static/simp-flow.png" alt=""></p><p>Threejs 主要参与顶点着色器和片元着色器的生成； 任务也主要处理模型变换，模型材质，色泽；</p><p>下面看下 Threejs 完整的运行流程： 下图来源<a href="https://www.cnblogs.com/wanbo/p/6754066.html" target="_blank" rel="noreferrer">图解 WebGL&amp;Three.js 工作原理</a><img src="https://raw.githubusercontent.com/huwuji/blog/master/FE_Tutorials/ThreeJs/static/whole-flow.png" alt=""></p><p>所以我们总结一句： Threejs 主要作用是在相机，灯光等环境因素的作用下，针对模型的自身形状，大小和材质，以及进行的变换（移动，旋转，缩放等）而进行渲染（调用 WebGL API）；</p><ol><li><a href="https://www.npmjs.com/package/three" target="_blank" rel="noreferrer">https://www.npmjs.com/package/three</a></li><li>图解 WebGL&amp;Three.js 工作原理 :<a href="https://www.cnblogs.com/wanbo/p/6754066.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/wanbo/p/6754066.html</a></li></ol>',17),s=[o];function a(n,i,h,b,g,c){return t(),r("div",null,s)}const u=e(p,[["render",a]]);export{L as __pageData,u as default};

import{_ as o,c as e,o as t,a as l}from"./app.ee7dae8a.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"异步 I/O","slug":"异步-i-o","link":"#异步-i-o","children":[]}],"relativePath":"node/2-异步IO.md"}'),p={name:"node/2-异步IO.md"},i=l('<h2 id="异步-i-o" tabindex="-1">异步 I/O <a class="header-anchor" href="#异步-i-o" aria-hidden="true">#</a></h2><h4 id="异步-i-o-1" tabindex="-1">异步 I/O <a class="header-anchor" href="#异步-i-o-1" aria-hidden="true">#</a></h4><ol><li><p>什么是异步？ 异步不用于阻塞和非阻塞，这是两个概念；们知道内核是只有阻塞和非阻塞的，并没有所谓的异步； 所以异步是什么呢？<br><strong>异步是对于阻塞和非阻塞情况进行多线程管理，达到所谓异步的效果；</strong> 所以这里理解就是<strong>异步的实现方案是基于多线程的；</strong></p><p>延伸一下： 这里其实还有一个问题我们需要注意，就是为什么会有阻塞和非阻塞之分； 阻塞是我们很好理解，就一直干一件事，直到这个事做完；那非阻塞有有何用呢？ 这里的作用涉及另一个计算机基础，及 I/O 和 CPU 是可以并行的；</p><p>反证一下，我们异步通常是做什么呢？不正是处理 I/O 吗？如果 I/O 和 CPU 在底层是不能并行的，我们的异步又又何用呢；</p><blockquote><p><strong>异步 I/O 能实现的基础：I/O 和 CPU 是可以并行的；</strong></p></blockquote><p>接着说，异步的实现方案是基于多线程的；那异步的主体是什么呢？js 中，我们称之为事件的东西；我们把这些事件合理的管理，分配到线程，再合适的时机执行； 所以进一步总结 <strong>异步的实现方案是基于事件机制和多线程；</strong></p><p>了解了异步 I/O 是什么后，我们再看看为什么需要异步 I/O?</p></li><li><p>为什么需要异步 I/O?</p><ul><li><p>从后端上来说： 异步 I/O 可以合理的分配 CPU 和 I/O 的资源使用，提升利用率； 同时也可以减少多个 I/O 操作的最后完成时间；类似于并行；（ps：这里讨论单线程的情况下）</p></li><li><p>从前端上来说： 异步可以很大程度上减少 UI 阻塞，提升用户体验；但前端资源获取的组素也取决于后端响应速度；</p></li></ul></li><li><p>异步 I/O 的实现原理？ <strong>异步的实现方案是基于事件机制和多线程；</strong> 以前有一些方案是基于轮训实现，实现方式太过于浪费 CPU；新的 I/O 实现机制利用了<strong>事件通知，执行回调</strong>的方式，然后利用<strong>线程池</strong>执行效率更高；</p></li><li><p>Node 的异步 I/O Node 的异步 I/O 主要分为 4 部分：</p><ul><li><p>事件循环：Node 自身的执行模型；</p></li><li><p>观察者： 判断是否有事件需要被处理的模式；</p><blockquote><p>事件循环是一个典型的生产者/消费者模型；异步 I/O，网络请求等则是事件的生产者，它们不断给 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理；</p></blockquote></li><li><p>请求对象：</p><blockquote><p>请求对象是异步 I/O 过程中的重要中间产物，所以的状态都保存在这个对象中，包括送入线程池等执行以及 I/O 操作完毕后的回调处理；</p></blockquote><p>简单来说，请求对象是执行信息，状态，以及回调函数的载体；一个请求对象随事件触发创建，之后穿梭于 Node 异步的各环节中，直到从请求对象中取除回调函数执行而消除；</p></li><li><p>执行回调：</p></li></ul></li></ol><blockquote><p>Node 中异步一般分为两部分；第一部分是组装好请求对象，送入到线程池中等待执行； 第二步是执行回调，进行回调通知；</p></blockquote><blockquote><p>Node 中 I/O 操作，不仅仅只限制于磁盘文件的读写；因为**nix 将计算机的磁盘文件，硬件，套接字等几乎所有计算机资源都被抽象成了文件；</p></blockquote><blockquote><p>事件循环机制: <a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/33058983</a></p></blockquote>',6),r=[i];function n(a,s,c,d,_,u){return t(),e("div",null,r)}const O=o(p,[["render",n]]);export{h as __pageData,O as default};

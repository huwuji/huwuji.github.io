import{_ as l,c as e,o as s,a}from"./app.b8d11a0b.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"Docker 入门笔记整理","slug":"docker-入门笔记整理","link":"#docker-入门笔记整理","children":[{"level":3,"title":"一. 什么是 Docker","slug":"一-什么是-docker","link":"#一-什么是-docker","children":[]},{"level":3,"title":"二. 优势","slug":"二-优势","link":"#二-优势","children":[]},{"level":3,"title":"三. 基本概念","slug":"三-基本概念","link":"#三-基本概念","children":[]},{"level":3,"title":"四. 一些具体操作指令","slug":"四-一些具体操作指令","link":"#四-一些具体操作指令","children":[]}]}],"relativePath":"engineering/docker入门学习笔记.md"}'),n={name:"engineering/docker入门学习笔记.md"},i=a(`<h2 id="docker-入门笔记整理" tabindex="-1">Docker 入门笔记整理 <a class="header-anchor" href="#docker-入门笔记整理" aria-hidden="true">#</a></h2><blockquote><p>原址：<a href="https://github.com/huwuji/blog/tree/master/notes/FE-thinking" target="_blank" rel="noreferrer">https://github.com/huwuji/blog/tree/master/notes/FE-thinking</a></p></blockquote><blockquote><p>实践 Demo 可看：<a href="https://github.com/huwuji/blog/tree/master/Demo/ssg-test" target="_blank" rel="noreferrer">https://github.com/huwuji/blog/tree/master/Demo/ssg-test</a></p></blockquote><h3 id="一-什么是-docker" tabindex="-1">一. 什么是 Docker <a class="header-anchor" href="#一-什么是-docker" aria-hidden="true">#</a></h3><p>能在通硬件与 OS 的机器上运行不同 OS 层面要求的应用程序。程序之间相互隔离，与虚拟机相比，有更轻便的体积，以及更高效的系统资源利用；</p><h3 id="二-优势" tabindex="-1">二. 优势 <a class="header-anchor" href="#二-优势" aria-hidden="true">#</a></h3><ul><li>一致的运行环境，安全的应用隔离；</li><li>更便捷的维护和扩展；</li><li>方便持续的部署和交付；</li><li>更快速的启动；</li><li>更高效的资源利用；</li></ul><h3 id="三-基本概念" tabindex="-1">三. 基本概念 <a class="header-anchor" href="#三-基本概念" aria-hidden="true">#</a></h3><ul><li>镜像 Image</li><li>容器 Container</li><li>仓库 Repository</li></ul><ol><li><p>镜像：<strong>静态的</strong> 首先镜像是一个文件对象（文件系统）--及一种<strong>特殊的文件对象</strong>；</p><ul><li>包含了 OS 文件系统：提供容器运行时所需要的库、资源、配置等；</li><li>包含了应用的文件对象；</li></ul><p>镜像的架构设计（分层架构）--- 分层存储，及由<strong>多层文件</strong>联合组成； <strong>镜像的构建是一层层的构建，已经构建的层没有变化，后一层的构建也不会影响前一层；</strong></p></li><li><p>容器：<strong>动态的</strong> 容器是镜像的运行环境；</p><ul><li><p>理解：<br><strong>从编程角度：镜像可以比作类（Class）,容器就是镜像的实例；容器可以被创建，启动，停止，暂停，删除等</strong></p></li><li><p>容器的结构： 以镜像为基础层，在其外层创建一或多层文件，及当前容器的<strong>存储层</strong></p></li><li><p>容器存储层的生命周期： <strong>存储层的生命周期跟随容器创建和消亡；</strong> 所以不应该在同期存储层写入数据，应该使用<strong>数据卷或绑定宿主目录</strong>； （我们在 docker 部署前端静态资源时，关于 nginx 的 conf 配置如上说设置）</p></li></ul></li><li><p>仓库： 及镜像的远程存储服务器，集中存储，分发镜像，同比 github； 形式如&lt;仓库名&gt;:&lt;标签&gt;---&gt;node:alpine</p></li></ol><h3 id="四-一些具体操作指令" tabindex="-1">四. 一些具体操作指令 <a class="header-anchor" href="#四-一些具体操作指令" aria-hidden="true">#</a></h3><ol><li><p>镜像---指令：</p><ul><li>查找镜像：<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">docker search node/&lt;name&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li></ul><p>输出结构： NAME: 名称 DESCRIPTION: 描述 OFFICIAL: 是否官方 AUTOMATED: 自动构建 ...</p><ul><li>获取镜像</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">docker pull &lt;repository&gt;:&lt;tag&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>补充：从镜像的拉取 log 我们也可以看出，镜像时一层层文件单独的下载，已经被其他镜像下载过的某层文件，不会重复下载</strong></p><ul><li><p>列出本地已下载镜像：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">docker image ls ｜ docker image ls node</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li><li><p>删除镜像：</p></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">    docker image rm [选项] &lt;镜像1&gt; &lt;镜像2&gt; ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 或</span></span>
<span class="line"><span style="color:#A6ACCD;">    docker rmi [image] &lt;image1&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    // &lt;镜像1&gt;可以是镜像短ID，镜像名，镜像摘要等</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li><p>构建镜像（本地镜像构建）</p><ul><li>第一步：编写 Dockerfile 脚本文件，利用本地的 Dockerfile 文件构建。这里要了解怎么编写 Dockerfile 脚本文件；</li><li>第二部：执行 docker 构建命令</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">    docker build [选项] &lt;上下文路径&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 如</span></span>
<span class="line"><span style="color:#A6ACCD;">    docker build -t image-name .</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 注意这里有个.</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>这个是表明是在当前命令的上下文目录下，查找 Dockerfile 文件，创建一个名文 image-name 的镜像；</strong></p></li><li><p>补充 Dockerfile 文件编写的常用指令</p><ul><li>FROM node:alpine as builder ---指定一个基本镜像</li><li>ENV NODE_ENV production ---设置环境变量</li><li>WORKDIR /code ---创建工作目录</li><li>ADD yarn.lock package.json /code ---往工作目录中添加文件</li><li>RUN yarn build ---运行指令，可以多次执行</li><li>EXPORT 8000 ---设置端口</li><li>CMD yarn start ---执行命令，<strong>只能使用一次</strong></li><li>COPY --from=builder /code/build /usr/share/nginx/html ---<strong>复制上一阶段构建打包好的静态包（dist）到 nginx 服务的静态文件存放目录下</strong></li></ul></li></ul></li><li><p>容器指令操作：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">// docker run [选项] 镜像名称 [命令] [参数]</span></span>
<span class="line"><span style="color:#A6ACCD;">docker run -it -P 8000:8000 -name containerName image-name  /bin/bash</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>以上是新建并启动一个容器</p><ul><li><p>常用选项：-d, -i,-t,-V[绑定卷],-P</p></li><li><p>终止｜启动｜重启 容器 docker stop [容器 id]<br> docker start<br> docker restart</p></li><li><p>查找容器 docker ps /docker container ps [-a]</p></li><li><p><strong>进入容器</strong> docker exec [-t] [容器 id]</p></li><li><p>查看容器日志 docker logs [容器 id]</p></li><li><p><strong>分析容器</strong> docker inspect [选项] [容器 id,...]</p></li></ul></li></ol><p>----todo--- 后续学习更新</p><blockquote><p>《深入浅出 Docker》</p></blockquote>`,14),t=[i];function o(r,p,c,d,g,u){return s(),e("div",null,t)}const C=l(n,[["render",o]]);export{k as __pageData,C as default};

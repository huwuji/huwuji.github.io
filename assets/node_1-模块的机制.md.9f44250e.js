import{_ as s,c as p,o as n,a as l}from"./app.ee7dae8a.js";const C=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"模块机制","slug":"模块机制","link":"#模块机制","children":[]}],"relativePath":"node/1-模块的机制.md"}'),o={name:"node/1-模块的机制.md"},e=l(`<h2 id="模块机制" tabindex="-1">模块机制 <a class="header-anchor" href="#模块机制" aria-hidden="true">#</a></h2><ol><li><p>CommonJs 规范</p><ul><li><p>1.1 起因：<br> Js 自身<strong>没有模块系统，没有标准接口，缺少标准库，缺乏包管理系统</strong>的问题，及 Js 应用中基本没有自动加载和安装依赖的能力； 为了处理 Js 没有标准的缺陷，设计了 CommonJs 规范，希望利用依据 CommonJs API 编写的应用具备<strong>跨宿主环境执行的能力</strong>， 如下：</p><ul><li>服务器断 Js 应用程序</li><li><strong>命令行工具</strong></li><li>客户端应用</li><li>桌面图形界面应用程序</li><li>混合应用...</li></ul><p>在 CommonJs 不断发展中，规范范围不断扩大，规范涵盖了<strong>模块</strong>，二进制，Buffer，字符集编码，I/O 流，进程环境，文件系统，套接字，单元测试，Web 服务器网关接口，<strong>包管理</strong>等</p></li><li><p>1.2 CommonJs 的模块规范 主要是对模块引用，模块定义，和模块标识这三部分定义； 1）模块引用：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">    var math= require(&#39;math&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>2)模块定义： 模块提供 exports 对象用于当前模块方式或者变量的导出； （ps：模块还存在一个 module 对象，代表模块本身）</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">   // 方式一：</span></span>
<span class="line"><span style="color:#A6ACCD;">   exports={</span></span>
<span class="line"><span style="color:#A6ACCD;">       add:function(){ }</span></span>
<span class="line"><span style="color:#A6ACCD;">   }</span></span>
<span class="line"><span style="color:#A6ACCD;">   // 方式二：</span></span>
<span class="line"><span style="color:#A6ACCD;">   module.exports={</span></span>
<span class="line"><span style="color:#A6ACCD;">       add:function(){}</span></span>
<span class="line"><span style="color:#A6ACCD;">   }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>3)模块标识 及传递给 require()方法的参数；<br> 规则：<strong>符合小驼峰命名的字符串，或者&#39;./&#39;，&#39;../&#39;开头的相对路径，或者/开头的绝对路径；</strong> 可以没有文件名后缀.js；</p><p>CommonJs 构建的这套模块导出和引入机制，使用户不必考虑变量污染，优于通过命民空间的方式处理变量污染；</p></li></ul><p>有了规范，接下来让我们看下 Node 的模块实现；</p></li><li><p>Node 的模块实现<br><strong>在 Node 中，模块分为两类：核心模块（Node 提供的模块），文件模块（用户编写的模块，用户自定义模块也是属于文件模块）</strong></p><p>要实现引用模块，需要经历 3 个步骤：</p><ul><li><strong>路径分析</strong></li><li><strong>文件定位</strong></li><li><strong>编译执行</strong></li></ul><p>核心模块中，部分核心模块在 Node 进程启动时，就是以二进制的格式存储在内存中，所以这部分的核心模块在引入时，文件定位（ps：在路径解析时，直接对应了内存中的地址，直接在内存中读取，也就不需要文件定位）和编译执行（ps：已经是以二进制方式存储的）这个两个步骤可以省略，并且<strong>在路径分析中优先判断</strong>，所以<strong>加载最快</strong>；</p><blockquote><p>ps：以上解释为什么核心模块加载最快; 核心模块加载仅次于缓存加载；</p></blockquote><blockquote><p><strong>什么是缓存加载？</strong> 缓存加载及 Node 机制中，类似于浏览器缓存静态文件机制，Node 也会缓存模块的引入，以减少二次引入时的开销；与浏览器缓存不同的是，Node 缓存是直接缓存编译和执行之后的对象；（缓存的是编译执行的结果；）</p></blockquote><p>文件模块是在运行时动态加载的，需要完整的 3 个步骤，比核心模块要慢； 在文件模块中，对于自定义模块的路径分析会更为复杂，需要按照<strong>模块路径的生成规则</strong>来查找；</p><blockquote><p>ps： 模块路径的生成规则： 从当前路径下开始，从下向上逐级递归查找 node_modules 目录下文件，直到根目录下 node_modules 目录；</p></blockquote><ul><li><p>2.1 <strong>路径分析：</strong> 及模块标识分析； 1）分析区分核心模块，相对路径的文件模块（./,../），绝对路径的文件模块，自定义模块（需从 node_modules 中寻找）；</p><p>2）核心模块<br> 核心模块处理的优先级仅次于缓存加载；（及分析后，如果有缓存，则先处理缓存加载，之后就处理核心模块）；</p><p>3）路径模块：（相对路径[.,..]和绝对路径模块[/]） 路径分析时，会先将路径转化为<strong>真实路径</strong>；（ps：编译执行后缓存结果时，也是以该真实路径为 key，缓存到内存中）</p><p>4）自定义模块 通过<strong>模块路径的生成规则</strong>，一层层向外查找，找到文件路径；</p></li><li><p>2.2 <strong>文件定位：</strong> 对于文件定位，需要按有无文件拓展名来分析，并考虑目录和包的情况；</p><ul><li><p>有拓展名： 直接匹配拓展名来定位；</p></li><li><p>无拓展名 (!!!这里是考虑的重点) 1）按&#39;.js&#39;,&#39;.json&#39;,&#39;.node&#39;的次序补全拓展名查找；</p><blockquote><p>ps: 这里需要调用 fs 模块来判断文件是否存在，这时逻辑是同步阻塞的执行判读;</p></blockquote><p>2）[!!!]文件补全拓展名后找不到具体文件，却定位到了<strong>目录文件</strong> 这个情况下，Node 会将此目录文件做为<strong>包</strong>处理；</p><p>针对包的文件定位处理方式为如下：</p><ul><li>先查找是否存在 package.json 文件，存在则从找到文件中的 main 属性定位文件，没有 main 属性或 main 属性有误，则依次查询 index.js，index.json；</li><li>无 package.json 文件，则也依次查询 index.js，index.json；</li><li>还找不到，则抛出异常；</li></ul><blockquote><p>ps： <strong>什么是包？</strong> 包是 Node 管理模块和代码的一种方式；也是 CommonJs 规范的一部分； CommomJs 包规范：如下 3. 包和 NPM</p></blockquote><blockquote><p>ps：所以当文件拓展名不是.js 时，补全拓展名，查找会更快；</p></blockquote></li></ul></li><li><p>2.3 <strong>编译执行</strong><br> 编译执行主要针对.js，.json，.node 来处理；这里我们就先不谈.node 的处理；</p><ul><li><p>对 Js 模块的编译 Node 对 Js 文件内容进行头尾包装，同时注入 require，exports， module.exports， <code>__dirname</code>，<code>__filename</code> 属性； 这样每个模块之间就都进行了作用域隔离； 具体如下：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">    (</span></span>
<span class="line"><span style="color:#A6ACCD;">        function (require,exports, module.exports,__dirname,__filename){</span></span>
<span class="line"><span style="color:#A6ACCD;">            // 模块代码</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    )</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li></ul></li></ul></li><li><p>包 CommonJs 的包规范分为<strong>包结构和包描述</strong>两个部分；</p><p>3.1） CommonJs 规范下的包结构：</p><pre><code>- package.json 包描述文件
- bin 用于存放可执行二进制文件的目录
- lib 用于存放 Js 代码的目录
- doc 用于存放文档的目录
- test 用于存放单元测试用例的代码
</code></pre><p>3.2） 包描述 --- 及 package.json 文件 包描述文件用于表达非代码相关的信息，它是一个 JSON 结构</p></li><li><p>NPM NPM 是对 CommonJs 包规范的一个实践，CommonJs 包规范是理论基础； 同时是 Node 包管理器， 帮组弯沉第三方模块的发布，安装和依赖等；</p><p>NPM 实践下，包描述的主要字段：</p><ul><li><p>name 包名，规定有小写的字母和数字组成；</p></li><li><p>description 包简介</p></li><li><p>version 版本号</p></li><li><p>keywords 关键字词组，NPM 中主要用来做分类搜索</p></li><li><p>licenses 当前包的许可证列表</p></li><li><p>bin !!!全局执行安装后，可以将脚本添加到执行路径中，作为命令行工具的方式使用</p></li><li><p>main 包的模块默认入口文件；当没有配置或配置文件路径找不到时，会再依次查找 index.js,index.node,index.json；</p></li><li><p>scripts 脚本说明对象；主要被包管理器用来安装，编译，测试，卸载包等；</p></li><li><p>dependencies 使用当前包所需要依赖的包列表；NPM 通过这个属性自动加载依赖；</p></li><li><p>devDependencies 开发时，一些模块需要的依赖；</p></li><li><p>peerDependencies</p></li><li><p>repository</p></li><li><p>author 作者</p></li><li><p>os 操作系统支持列表</p></li><li><p>cpu CPU 架构的支持列表，如 arm，x86，x86_64</p></li><li><p>engines</p></li><li><p>...</p><p>4.1) 包安装 包在安装的时候需要注意安装方式，</p><ul><li><p>全局安装：根据包描述文件的 bin 字段配置，将实际的脚本链接到与 Node 可执行文件相同的路径下</p><p>npm install express -g 如</p></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">&quot;bin&quot;:{</span></span>
<span class="line"><span style="color:#A6ACCD;">    &quot;express&quot;: &quot;./bin/express&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li><p>局部安装 npm install xxx</p></li><li><p>设置镜像源安装 自定义安装来源</p><p>4.2) 发布包</p></li><li><p>编写包模块代码和包描述</p></li><li><p>注册包仓库账号</p></li><li><p>上传包 npm publish 《folder》</p><p>4.3) 包权限的管理 通过 npm owner 命令</p><p>4.4）包的分析 通过 npm ls 命令</p><p>4.5)!!!包的质量检测和安全检测</p></li></ul></li></ul></li><li><p>前后端共用模块</p><p>前后端的 Js 分别处于 Http 的两端，位置不同，角色不同；对于服务器端的 Js，相同的代码，模块需要被执行多次，瓶颈在于 CPU 和内存等资源；浏览器端的 Js，则是需要从服务端分发到多个客户端执行，瓶颈是带宽； 一个从磁盘加载，一个从网路加载，两者的加载速度不在一个数量级上；</p><p>由于 Node 的模块引入过程，几乎全都是同步引入的；CommonJs 自定的规范不太适合前端应用场景，前端更希望能异步引入；</p><p>所以参考 CommonJs 的规范，也出现了适合前端的模块加载规范；</p><ul><li><p>AMD 简单来说是依赖前置，异步加载</p></li><li><p>CMD 简单来说是依赖就近、延迟执行</p></li></ul><blockquote><p>这里 AMD 和 CMD 的 define 定义主要是为了作用域隔离。在 Node 中，Node 是默认通过隐式包装实现；包装模块，并传入 require，exports， module.exports...</p></blockquote><p>后期更多其他</p><ul><li>UMD</li><li>ESM</li></ul></li></ol>`,2),i=[e];function a(t,r,c,d,u,g){return n(),p("div",null,i)}const A=s(o,[["render",a]]);export{C as __pageData,A as default};
